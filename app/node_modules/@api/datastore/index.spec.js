/* eslint-env mocha */
'use strict'

const { expect } = require('chai')
const T = require('./index.js')
const CONNECTION_STRING = 'sqlite::memory:'

describe('the datastore module', () => {
  it('should export a function', () => {
    const expected = 'function'
    const actual = typeof T
    expect(actual).to.equal(expected)
  })

  describe('the instance returned by the function', () => {
    it('should always refer to the same instance', () => {
      const expected = T()
      const actual = T()
      expect(actual).to.equal(expected)
    })

    it('should have a property called "createUser"', () => {
      const instance = T()
      expect(instance).to.have.property('createUser')
    })

    it('should have a property called "init"', () => {
      const instance = T()
      expect(instance).to.have.property('init')
    })

    it('should have a property called "reset"', () => {
      const instance = T()
      expect(instance).to.have.property('reset')
    })

    it('should have a property called "provider"', () => {
      const instance = T()
      expect(instance).to.have.property('provider')
    })

    describe('the "init" property', () => {
      let instance
      const ERR_INVALID_INPUT = 'the init method requires a connection string parameter that is in the form of a URI'

      before(() => {
        instance = T()
        return instance.init(CONNECTION_STRING)
      })

      after(() => {
        return instance.reset()
      })

      it('should be a function', () => {
        const expected = 'function'
        const actual = typeof instance.init
        expect(actual).to.equal(expected)
      })

      describe('the returned value', () => {
        it('should be a promise', () => {
          const result = instance.init()
          return expect(result).to.be.rejected
        })
      })

      it('should throw an error if param is missing', () => {
        const result = instance.init()
        return expect(result).to.be.rejectedWith(ERR_INVALID_INPUT)
      })

      it('should throw an error for invalid parameter values', () => {
        const badValues = ['', 5, null, 'not a uri']
        return Promise.all(
          badValues.map((value) => {
            return expect(instance.init(value)).to.be.rejectedWith(ERR_INVALID_INPUT)
          })
        )
      })

      context('when provided a valid connection string', () => {
        it('should work', () => {
          const result = instance.init('sqlite::memory:')
          return expect(result).to.be.fulfilled
        })
      })
    })

    describe('the "createUser" property', () => {
      let instance

      before(() => {
        instance = T()
        return instance.init(CONNECTION_STRING)
      })

      after(() => {
        return instance.reset()
      })

      it('should be a function', () => {
        const expected = 'function'
        const actual = typeof instance.createUser
        expect(actual).to.equal(expected)
      })

      describe('the returned value', () => {
        before(() => {
          return instance.reset()
        })

        context('when the init method has not been called', () => {
          it('should be rejected', () => {
            const result = instance.createUser()
            return expect(result).to.be.rejectedWith('Please call init first')
          })
        })

        context('when the init method has been called', () => {
          it('should be resolve to a number', () => {
            return instance.init(CONNECTION_STRING)
              .then(() => {
                const result = instance.createUser({
                  username: 'test@email.com',
                  password: 'test',
                  name: {
                    first: 'firstName',
                    last: 'lastName'
                  }
                })
                return expect(result).to.eventually.be.a('number')
              })
          })
        })
      })
    })

    describe('the "provider" property' , () =>{
      it ('should be read-only' , () => {
       expect( () => {
        const instance = T()
        instance.provider = 42 
       }).to.throw(/^Cannot set property provider/)
         
      })
    })

    describe('the "reset" property', () => {
      let instance

      before(() => {
        instance = T()
        return instance.init(CONNECTION_STRING)
      })

      after(() => {
        return instance.reset()
      })

      it('should be a function', () => {
        const expected = 'function'
        const actual = typeof instance.reset
        expect(actual).to.equal(expected)
      })

      describe('the returned value', () => {
        it('should be a promise', () => {
          const result = instance.reset()
          return expect(result).to.be.fulfilled
        })
      })
    })
  })
})
